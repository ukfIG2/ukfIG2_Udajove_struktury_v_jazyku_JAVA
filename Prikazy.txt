-001.TYPY_HODNOT

    Cele cisla
        byte
        short
        int
        long
    S desatinnou ciarkou
        float
        double
    boolean
        true
        false
    Znaky
        char
            char a=''
    Retazce
        String = ""
                 null;

-002.LOGICKE OPERATORY

    &&                          - ukonci vyhodnotenie v momente, ze podmienka je nepravdiva
    &       -   and a sucasne   - vyhodnocuje vyraz do konca
    |
    ||      -   or alebo

-003.SPECIALNE ZNAKY

    \t	– 	vloží do textu tabulátor
    \b 	– 	vloží do textu backspace
    \n 	– 	vloží do textu nový riadok
    \r 	– 	vloží do textu znak pre návrat vozíka
    \f 	– 	vloží do textu vertikálny tabulátor
    \' 	– 	vloží do textu apostrof
    \" 	– 	vloží do textu úvodzovky
    \\ 	– 	vloží do textu spätné lomítko

-004.PRAZDNY OBSAH CELOCISELNEJ PREMMENNEJ JE null alebo ""

-005.MINIMALNA MAXIMALNA HODNOTA
    MIN = Integer.MIN_VALUE;
    MAX = Integer.MAX_VALUE;

000.ZAKLAD

    public class _01 {

        public static void main(String[] args) {
            // TODO Auto-generated method stub
        }
    }

001.Prikaz VYSTUPU

    System.out.println("");    - vypise a to za tym odriadkuje
    System.out.print("");      - vypise do riadku

002.Prikaz VSTUPU

    import java.util.Scanner;   -   importujeme kniznicu
    Scanner vstup = new Scanner(System.in);     -   vytvorime Scanner
    int a = vstup.nextInt();    -   nacitame cisla
                 .nextFloat();   -   nacitame realne cisla
                 .nextDouble();  -  nacitame desatinne cislo
                 .next().charAt(0); - nacitame charakter
                 .nextLine();       -   nacitame textovy udaj

003.PODMIENENY PRIKAZ

    if (podmienka){
        prikaz1;
    }
    else {
        prikaz2;
    }

004.CYKLUS S PEVNYM POCTOM

    for (i=1; i<n; i=i+1){
    prikaz1;
    prikaz2;
    }
        inicializacnyVyraz; podmienkaUkoncenia; krok
        ak je podmienka splnena vykona prikaz

005.CYKLUS S NEZNAMYM POCTOM OPAKOVANI

    cyklus sa vykona, dokedy je splnena podmienka
    while (podmienka) {
    prikaz;
    }

006.CYKLUS S PODMIENKOU NA KONCI

    Vykona sa aspon raz, potom sa skontroluje podmienka
    do {
    prikaz1;
    prikaz2;
    }   while (podmienka);

007.ZAOKRUHLENIE

    Math.round();
    Výsledkom operácie je celé číslo, avšak nie typu int, s ktorým sme doposiaľ pracovali, ale typu long, ktorý dokáže uchovávať väčšie hodnoty.
    Musi byt pred premennou 'long'

008.ZAOKRUHLENIE NA DESATINNE MIESTA

    double pi = 3.14159;                    - Takze najprv to zaokruhli a potom vi-deli
    double pi2 = Math.round(pi*100)/100;
    Vynásobenie hodnoty premennej 100 posunie desatinnú čiarku o dve miesta na 314.159. Táto hodnota sa prostredníctvom round zaokrúhli na celé číslo, t.j. 314 a napokon sa vydelením 100 sa desatinná čiarka posunie o dve desatinné miesta doľava. Výsledkom je 3.14

009.Pretypovanie

    long b = 15;
    int c = (int) b;        -   totototototok
    System.out.print(c);

----------------------------------------------------------Retazce--STRING
010.VELKOST STRINGU

    int dlzka = premenna.length()
                        .length  - length pri poliach nema zatvorky

011.SPAJANIE STRINGU

    +
    alebo
    concat = retazec1.concat(retazec2);

012.ZISKANIE ZNAKU

    char a = Priklad.charAt(0);

    ak ideme od zadu

    int dlzka = premenna.length();
    char a = premenna.charAt(dlzka-1);

013.ZISKANIE POD_RETAZCA [REZ STRINGU]

    String premenna_01 = "AHOJ";
    "String nazov premennej = premenna.substring(int beginIndex, int endIndex);"
    String premenna_02 = premenna_01.substring(00,11);

014.POROVNAVANIE RERAZCOV

    boolean equals(Object anObject)
    premenna.equals(premenna);
    a.equals(b);

015.POROVNAVANIE RETAZCOV BEZ VELKOSTI PISMEN

    a.equalsIgnoreCase(b);

016.POROVNAVANIE RETAZCOV LEXIKOGRAFICKY

    int compareTo(String anotherString)
    int i = a.comprareTo(b);
	int compareToIgnoreCase(String anotherString)

017.PREHLADAVANIE RETAZCA

    String text = "m a m a   m a   E m u";
                   0 1 2 3 4 5 6 7 8 9 10
    int prva = text.indexOf("ma");
    int posledna = text.lastIndexOf("ma")
    PRVA 0, POSLEDNA 5

018.PRETYPOVANIE STR NA INT V RETAZCI

    Integer.parseInt(premenna);

019.PRETYPOVANIE INT NA STR

    String.valueOf(premenna)

020.PRETYPOVANIE CHAR NA INT

    Character.getNumericValue()

021.Kontrola ci je

    Character.isDigit()
             .isLetter()
             .isWhitespace()
             .UpperCase()
             .isLowerCase()
21.ZMENA CHARAKTERU

    Character.toUpperCase()
             .toLowerCase()
             .toString()

22. VIACNASOBNE VETVENIE

    switch(premenna){
    case 1: prikaz1;
            prikaz2;
            break;
    case 2: prikaz1
            prikaz2
            break;
    default:    prikaz1
                prikaz2
                break;
    }

    default     -   ak sa nic z "case" nestane tak nastae default.
    switch      -   kontroluje hodnotu v premmenej s case-om

23. Vynimky

    try {}            -   zacina blok prikazov
    catch(exception e){}   -   odchyti chybu
    finally{}         -   vzdy sa vykona

24. Chyby

    1   catch(NumberFormatException e) {
        System.out.println("Retazec nie je cislo!");

    2   catch(ArithmeticException e) {
        System.out.println("Nulou sa nedeli!");

25. POLIA ZOZNAMY

    int[] arr1;
    int arr2[];
    double arr3[];
    String[] strs;  -   inicializacia pola

26. VYHRADENIE PAMATE

new
        int[] arr1;
        arr= new int[100];
        int arr[] = new int[50];

27. Pocet prvkov

    pocetPrvkov = premenna.length;

28. Vkladanie do zoznamu

    Scanner vstup = new Scanner(System.in);
        int[] arr = new int[10];
        for(int i = 0; i < 5; i++) {
        arr[i] = vstup.nextInt();
        }

29. KONSTATNA PREMENNA

    final int pocet = 10;

30. NAHODNE CISLA

    Math.random()
        0.0<=Math.random()<1.0.     -Nam da iba hodnotu od 0.0po1.0.
        Math.random()*10
    Zaporne
        arr[i] = (int) (-50 + Math.random() * 101);

31. PRETYPOVANIE NAHODNEHO CISLA Z DOUBLE NA CELE

    int num = (int)(Math.random() * 9);     -od 0 do 8

32. TRIEDENIE V POLOCH

    for(int i = 0; i < arr.length-1; i++) { // počet prechodov
   for(int j = 0; j < arr.length-i-1; j++) { // posun po posledný, predposledný atď (n-i) prvok
      if (arr[j]>arr[j+1]) {  // výmena prvkov
            int pom = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = pom;
      }
   }
 }

33.  SPLIT

    premenna.split()     -príkaz split rozdelí obsah premennej riadok do poľa,  pričom ako oddeľovač sa uvažuje znak  v argumente
        ,;" "

34. Matice

    int n = vstup.nextInt();
    nt[][] matica = new int[m][n];
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            matica[][] = vstup.();

35. Precod po cellom POLI foreach
    for(int "premenna" : "premenna_pola")

-----------------------------------------------------------Subory

36. Na vytvorenie súboru potrebujeme FileWriter, ktorý zabezpečí vytvorenie a následné sprístupnenie súboru a poskytne nástroje na načítavanie znakov.

    FileWriter fW = new FileWriter("file.txt");

37. Následne vytvorené spojenie poskytneme BufferedWriter-u, ktorý existujúci FileWriter rozšíri o schopnosť zapisovať celú postupnosť znakov.

    BufferedWriter bW = new BufferedWriter(fW);

38. Celý zápis môžeme vykonať aj v jednom kroku:

    BufferedWriter bW = new BufferedWriter(new FileWriter("file.txt"));

39. Pre zápis reťazca do súboru používame príkaz

    bW.write(txt);

40. Pre odriadkovanie

    bW.newLine();

41. Stream je po skončení operácií potrebné uzavrieť kvôli uloženiu údajov z medzipamäte a uvoľneniu prístupu k súboru. Používame na to príkaz:

    bW.close();
    Zatvorení BufferedReader-u sa zavrie aj jemu podriadený FileReader.

42. Samotné čítanie riadku sa vykoná pomocou:

    String s = bR.readLine();

43. Cesta k suboru

    String myFile = "C:\\adresar\\udaje.txt";

44. Vzor pre subory
----TOTOK

import java.io.*;
public class JavaApp {

    public static void main(String[] args) {
        // sem napiste svoj kod

      	String nazov = "nazov/premenna suboru";

      try{
        FileReader FR = new FileReader(nazov);
      	BufferedReader BR = new BufferedReader(FR);
        String riadok = "";
        while(riadok!=null){
        riadok = BR.readLine();
          if(riadok!=null) System.out.println(riadok); //zobrazi cely riadok
        }//while_riadok
        BR.close();
      }//try
      catch(IOException e){
      	System.out.println(e.getMessage());
      	}//catch

----TOTOK

    String riadok;
    BufferedReader bR;
    try  {
        bR = new BufferedReader (new FileReader("data.txt"));
        while ((riadok = bR.readLine()) != null )  {
        }
    } catch (IOException e) {
        System.out.println(e.getMessage());
    } finally {
        bR.close();
    }

45. Pripravime na nacitanie
        BufferedReader
        BufferedReader bW = new BufferedReader(fW)
-----------------------------------------------------------Subory

------------------------------------------------------------
Objektovo orientovane programovanie

.ATRIBUTY	-	Pamäť predstavujú premenné, pričom v terminológii OOP ich označujeme ako
.METODY		-	Schopnosti objektu sú popísané pomocou príkazov programovacieho jazyka a predstavujú čiastkové algoritmy, ktoré riešia jednoduché úlohy. Označujeme ich ako
.CLASS		-	CLASS je predpis, ktorý určuje, aké budú mať objekty vytvorené na základe jej schopnosti a aké atribúty budú používať. V pamäti však zatiaľ neexistuje a teda jej premenné nemožno využívať ani jeho metódy nemožno volať.
			Trieda je predpisom, ktorý hovorí aké atribúty a schopnosti má mať inštancia
.INSTANCIA	-	predstavuje už konkrétny objekt vytvorený v pamäti, ktorý nám poskytuje svoje atribúty i schopnosti reprezentované metódami.
			Inštancia je už konkrétny prvok, ktorý MÁ vlastnosti a JE SCHOPNÝ vykonávať činnosti
.VYTVORENIE PAMATE PRE INSTANCIU
			napr. Strom smrek = new Strom();
.VOID       -   U metódy, ktorá len vykoná príkazy a nevracia žiadnu hodnotu, uvádzame ako typ void


46. public void setAtribut(typ a) { atribut = a; } // prípadne s potrebnými kontrolami
    Metódam, ktoré nastavujú hodnoty hovoríme settery a majú podobu:

47. public typ getAtribut() { return atribut; }
    Metódam, ktoré vracajú hodnoty hovoríme gettery, majú vždy typ zodpovedajúci typu atribútu, ktorého hodnotou vracajú a majú podobu

48. this
    ktoré určuje, že ide o atribút triedy resp. inštancie:


